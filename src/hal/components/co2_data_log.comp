component co2_data_log;
option userspace;
pin in bit log_enable;
pin in bit work_enable;
pin in s32 data-s32-#[16];
pin in float data-float-#[16];
pin in bit data-gpio-#[16];
pin out float work_time=0;
pin out float average_work_time=0;
pin out float overall_work_time=0;
pin in bit lco2_a_sel;
pin in bit lco2_b_sel;
param rw bit enable;
param rw bit prev-gpio-#[16];
param rw s32 print-format-#[48]=0;
param rw s32 timeout;
variable int s32_num;
variable int float_num;
variable int gpio_num;
variable int print_len;
variable int log_count;
license "GPL";
;;
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>
#include <sys/time.h>

void user_mainloop(void) {
    int32_t i, j, s_index, f_index, b_index, str_len, prev_enable[16],
            prev_work_enable[16], n; 
    char str[256];
    char *line;
    struct tm *tmp;
    time_t t;
    time_t rawtime;
    struct tm * timeinfo;
    char buffer[80];

    FILE *hfile[16], *log_name;
    struct timeval start, last;
    long seconds, useconds;
    double mtime = 0, last_mtime = 0, time_diff = 0;
    i=0;
    FOR_ALL_INSTS() {
      s32_num = 16;
      float_num = 16;
      gpio_num  = 16;
      log_count = 0;
      sprintf(str, "data_log_%01d_%02d.csv",i, log_count);
      hfile[i] = fopen(str, "w");
      i++;
    }
    while(1){
        i = 0;
        FOR_ALL_INSTS() {
            if (i==0) {
                usleep(timeout*1000);
            }
            enable = log_enable && work_enable;

            if (work_enable) {
                if (prev_work_enable[i] == 0) {
                    log_count+=1;
                    gettimeofday(&start, NULL);
                    last_mtime = 0;
                    work_time = 0;
                }
                gettimeofday(&last, NULL);
                seconds  = last.tv_sec  - start.tv_sec;
                useconds = last.tv_usec - start.tv_usec;
                mtime = (double) ((seconds) + useconds*0.000001);
                time_diff = mtime - last_mtime;
                last_mtime = mtime;
               
                work_time += time_diff;
                overall_work_time += time_diff;
                prev_work_enable[i] = 1;
            } else {
                if (prev_work_enable[i] == 1) {
                   // overall_work_time += mtime;                         
                   average_work_time = overall_work_time / log_count;
                }
                prev_work_enable[i] = 0;

            }   

            if (enable) {
                if(prev_enable[i]==0) {
                    log_name = fopen("/tmp/data_log.tmp", "r");

                    if (log_name != NULL) {
                        time ( &rawtime );
                        timeinfo = localtime ( &rawtime );
                        strftime (buffer,80,"%Y_%m_%d_%H_%M_%S",timeinfo);
                        getdelim(&line, &n, '_', log_name);
                        sprintf(str, "%s%s.csv", line, buffer);
                        fprintf(stderr,"file name: %s\n", str);
                        hfile[i] = fopen(str, "w");
                        fprintf(hfile[i], "Program name, Time(s),");
                        if (lco2_b_sel) {
                            fprintf(hfile[i], "LCO2(B), CDA, X(in), X_F(in/s), X_FERROR(in), Y(in), Y_F(in/s),Y_FERROR(IN), Spindle Vel(RPS), Spindle_FERROR(deg)");
                        } else {
                            fprintf(hfile[i], "LCO2(A), CDA, X(in), X_F(in/s), X_FERROR(in), Y(in), Y_F(in/s),Y_FERROR(IN), Spindle Vel(RPS), Spindle_FERROR(deg)");
                        }

                        while(getline(&line, &n, log_name)!=-1) {
                            fprintf(hfile[i],"%s",line);
                        }
                        fclose(log_name);
                        log_name = NULL;
                    } else { // use default file name
                        sprintf(str, "data_log_%01d_%02d.csv", i, log_count);
                        hfile[i] = fopen(str, "w");
                    }
                    
                    
                }
                s_index = 0;
                f_index = 0;
                b_index = 0;
                print_len = 0;
                while(print_format(print_len)) print_len += 1;
                if(print_len>0) {
                //     gettimeofday(&last, NULL);
                //     seconds  = last.tv_sec  - start.tv_sec;
                //     useconds = last.tv_usec - start.tv_usec;
                //     mtime = (double) ((seconds) + useconds*0.000001);
                    fprintf(hfile[i], " , %5.3f,", mtime);
                }
                for(j=0; j<print_len; j++) {
                    
                    switch(print_format(j)) {
                    case 1:
                      if(s_index < s32_num) { 
                          fprintf(hfile[i],"%d ", data_s32(s_index));
                          s_index++;
                      }
                      break;
                    case 2:
                      if (f_index < float_num) {
                          fprintf(hfile[i], "%.7f ", data_float(f_index));
                          f_index++;
                      }
                      break;
                    case 3:
                      if (b_index < gpio_num) {
                          fprintf(hfile[i], "%1d ", data_gpio(b_index));
                          prev_gpio(b_index) = data_gpio(b_index);
                          b_index++;
                      }
                      break;
                    case 4: // for io toggle
                      if (b_index < gpio_num) {
                          if (prev_gpio(b_index) != data_gpio(b_index)) {
                              t = time(NULL);
                              tmp = localtime(&t);
                              strftime(str, sizeof(str), "%Y/%m/%d %H:%M:%S",tmp);
                              fprintf(hfile[i], "%s", str);     
                              //fprintf(stderr, "%s\n", str);
                          } else {
                              fprintf(hfile[i], "0");
                          }
                          prev_gpio(b_index) = data_gpio(b_index);
                      }
                    }
                    if(j+1<print_len) {
                        fprintf(hfile[i],",");
                    } else {
                        if(print_len > 0) {
                            fprintf(hfile[i],"\r\n");
                        }
                    }
                }
                fflush(hfile[i]);
                prev_enable[i] = 1;
            } else {
                if(prev_enable[i] == 1) {
                    fclose(hfile[i]);
                    // over_all_work_time += mtime;
                    // average_work_time = over_all_work_time / log_count; 
                }
                prev_enable[i] = 0; 
            }
            i++;

        }

    }
}
// vim:sw=4:sts=4:et:
